import runtime from "./Runtime.mjs";
import MutMap from "./MutMap.mjs";
import Predef from "./Predef.mjs";
import Iter from "./Iter.mjs";
import Option from "./Option.mjs";
let Examples1;
(class Examples {
  static {
    Examples1 = Examples;
    let tmp, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8, tmp9, tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17, tmp18, tmp19, tmp20, tmp21, tmp22, tmp23, tmp24;
    this.examples = MutMap.empty;
    tmp = new globalThis.RegExp("^(?://\\u2502.*|:.*)$\n", "gm");
    this.diffTestPattern = tmp;
    tmp1 = new globalThis.RegExp("(?<=import \")(?:../)*(?:./)?mlscript-compile/(\\w+\\.mls)(?=\")", "gm");
    this.compileImports = tmp1;
    tmp2 = Examples.removeDiffTests(":js\n\nopen annotations\n\ndata class Formula with\n  constructor\n    Var(name: Str)\n    Pred(name: Str, arg: Formula)\n    And(left: Formula, right: Formula)\n    Or(left: Formula, right: Formula)\n\npattern Dnf = Or(Dnf, Dnf) | Atoms\npattern Atoms = And(Atoms, Atoms) | Atom\npattern Atom = Pred | Var\n\nfun isDnf(x) = x is @compile Dnf\n\nlet f1 = Var(\"x\")\nlet f2 = Pred(\"P\", Var(\"y\"))\n//\u2502 f1 = Var(\"x\")\n//\u2502 f2 = Pred(\"P\", Var(\"y\"))\n\nf1 is Dnf\n//\u2502 = true\n\nisDnf of f1\n//\u2502 = true\n\nf2 is Dnf\n//\u2502 = true\n\nisDnf of f2\n//\u2502 = true\n\nlet f3 = And(f1, f2)\n//\u2502 f3 = And(Var(\"x\"), Pred(\"P\", Var(\"y\")))\n\nf3 is Dnf\n//\u2502 = true\n\nisDnf of f3\n//\u2502 = true\n\nlet f4 = Or(f3, Pred(\"Q\", Var(\"z\")))\n//\u2502 f4 = Or(And(Var(\"x\"), Pred(\"P\", Var(\"y\"))), Pred(\"Q\", Var(\"z\")))\n\nf4 is Dnf\n//\u2502 = true\n\nisDnf of f4\n//\u2502 = true\n\nlet f5 = Or(And(Pred(\"A\", Var(\"a\")), Pred(\"B\", Var(\"b\"))), Pred(\"C\", Var(\"c\")))\n//\u2502 f5 = Or(And(Pred(\"A\", Var(\"a\")), Pred(\"B\", Var(\"b\"))), Pred(\"C\", Var(\"c\")))\n\nf5 is Dnf\n//\u2502 = true\n\nisDnf of f5\n//\u2502 = true\n\nlet cnf1 = And(Or(Var(\"x\"), Var(\"y\")), Pred(\"P\", Var(\"z\")))\n//\u2502 cnf1 = And(Or(Var(\"x\"), Var(\"y\")), Pred(\"P\", Var(\"z\")))\n\nlet cnf2 = And(Or(Var(\"a\"), Var(\"b\")), Or(Pred(\"P\", Var(\"c\")), Var(\"d\")))\n//\u2502 cnf2 = And(Or(Var(\"a\"), Var(\"b\")), Or(Pred(\"P\", Var(\"c\")), Var(\"d\")))\n\nlet cnf3 = And(And(Or(Var(\"x\"), Pred(\"Q\", Var(\"y\"))), Or(Var(\"z\"), Var(\"w\"))), Or(Pred(\"R\", Var(\"u\")), Var(\"v\")))\n//\u2502 cnf3 = And(And(Or(Var(\"x\"), Pred(\"Q\", Var(\"y\"))), Or(Var(\"z\"), Var(\"w\"))), Or(Pred(\"R\", Var(\"u\")), Var(\"v\")))\n\nlet cnf4 = And(Or(And(Var(\"m\"), Var(\"n\")), Var(\"o\")), Or(Pred(\"S\", Var(\"p\")), And(Var(\"q\"), Var(\"r\"))))\n//\u2502 cnf4 = And(Or(And(Var(\"m\"), Var(\"n\")), Var(\"o\")), Or(Pred(\"S\", Var(\"p\")), And(Var(\"q\"), Var(\"r\"))))\n\nlet cnf5 = And(Or(Var(\"a\"), Or(Var(\"b\"), Var(\"c\"))), And(Or(Pred(\"T\", Var(\"d\")), Var(\"e\")), Or(Var(\"f\"), Var(\"g\"))))\n//\u2502 cnf5 = And(Or(Var(\"a\"), Or(Var(\"b\"), Var(\"c\"))), And(Or(Pred(\"T\", Var(\"d\")), Var(\"e\")), Or(Var(\"f\"), Var(\"g\"))))\n\nlet cnf6 = And(Or(Var(\"x\"), And(Var(\"y\"), Or(Var(\"z\"), Var(\"w\")))), Or(Pred(\"U\", Var(\"t\")), Var(\"s\")))\n//\u2502 cnf6 = And(Or(Var(\"x\"), And(Var(\"y\"), Or(Var(\"z\"), Var(\"w\")))), Or(Pred(\"U\", Var(\"t\")), Var(\"s\")))\n\nprint of cnf1 is Dnf\nprint of cnf2 is Dnf\nprint of cnf3 is Dnf\nprint of cnf4 is Dnf\nprint of cnf5 is Dnf\nprint of cnf6 is Dnf\n//\u2502 > false\n//\u2502 > false\n//\u2502 > false\n//\u2502 > false\n//\u2502 > false\n//\u2502 > false\n\npattern Dnf'(pattern P) = Or(Dnf'(pattern P), Dnf'(pattern P)) | Atoms'(pattern P)\npattern Atoms'(pattern P) = And(Atoms'(pattern P), Atoms'(pattern P)) | Atom'(pattern P)\npattern Atom'(pattern P) = Pred(_, P) | Var\n\npattern DeepDnf = Dnf'(pattern DeepDnf)\n\nfun isDeepDnf(f) = f is @compile DeepDnf\n\nprint of isDeepDnf of f1\nprint of isDeepDnf of f2\nprint of isDeepDnf of f3\nprint of isDeepDnf of f4\nprint of isDeepDnf of f5\n//\u2502 > true\n//\u2502 > true\n//\u2502 > true\n//\u2502 > true\n//\u2502 > true\n\nprint of isDeepDnf of cnf1\nprint of isDeepDnf of cnf2\nprint of isDeepDnf of cnf3\nprint of isDeepDnf of cnf4\nprint of isDeepDnf of cnf5\nprint of isDeepDnf of cnf6\n//\u2502 > false\n//\u2502 > false\n//\u2502 > false\n//\u2502 > false\n//\u2502 > false\n//\u2502 > false\n\npattern Cnf'(pattern P) = And(Cnf'(pattern P), Cnf'(pattern P))\npattern DnfOrCnf = Dnf'(DnfOrCnf) | Cnf'(DnfOrCnf)\n");
    tmp3 = MutMap.insert("DnfCnf.mls", {
    "name": "DNF and CNF", "group": "Nondeterministic", "source": tmp2
    });
    tmp4 = Predef.pipeInto(Examples.examples, tmp3);
    tmp5 = Examples.removeDiffTests(":js\n\nopen annotations\n\nimport \"../../../mlscript-compile/Stack.mls\"\nimport \"../../../mlscript-compile/Iter.mls\"\nimport \"../../../mlscript-compile/Option.mls\"\n\nopen Stack\nopen Option { Some, None }\n\nfun list(...elements) = elements Iter.toStack()\n\n// This is a helper function to print the addition of two numbers.\nfun (++) addWithPrint(x, y) =\n  let result = x + y\n  print of \"\" + x + \" + \" + y + \" = \" + result\n  result\n\npattern DoubleList = Nil | (Int :: Int :: DoubleList)\n\npattern SumList = (Nil => 0) | (((Int as hd) :: (SumList as tl)) => hd ++ tl)\n\nNil is SumList(0)\n//\u2502 = true\n\nlet _1234 = list(1, 2, 3, 4)\nlet _1234567 = list(1, 2, 3, 4, 5, 6, 7)\n//\u2502 _1234 = Cons(1, Cons(2, Cons(3, Cons(4, Nil))))\n//\u2502 _1234567 = Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Cons(6, Cons(7, Nil)))))))\n\n_1234 is SumList(10)\n//\u2502 > 4 + 0 = 4\n//\u2502 > 3 + 4 = 7\n//\u2502 > 2 + 7 = 9\n//\u2502 > 1 + 9 = 10\n//\u2502 = true\n\n_1234567 is SumList(28)\n//\u2502 > 7 + 0 = 7\n//\u2502 > 6 + 7 = 13\n//\u2502 > 5 + 13 = 18\n//\u2502 > 4 + 18 = 22\n//\u2502 > 3 + 22 = 25\n//\u2502 > 2 + 25 = 27\n//\u2502 > 1 + 27 = 28\n//\u2502 = true\n\n_1234567 is SumList(42)\n//\u2502 > 7 + 0 = 7\n//\u2502 > 6 + 7 = 13\n//\u2502 > 5 + 13 = 18\n//\u2502 > 4 + 18 = 22\n//\u2502 > 3 + 22 = 25\n//\u2502 > 2 + 25 = 27\n//\u2502 > 1 + 27 = 28\n//\u2502 = false\n\n_1234 is DoubleList\n//\u2502 = true\n\n_1234567 is DoubleList\n//\u2502 = false\n\nfun sum(xs) = if xs is SumList as output then Some(output) else None\n\nsum of _1234\n//\u2502 > 4 + 0 = 4\n//\u2502 > 3 + 4 = 7\n//\u2502 > 2 + 7 = 9\n//\u2502 > 1 + 9 = 10\n//\u2502 = Some(10)\n\nsum of _1234567\n//\u2502 > 7 + 0 = 7\n//\u2502 > 6 + 7 = 13\n//\u2502 > 5 + 13 = 18\n//\u2502 > 4 + 18 = 22\n//\u2502 > 3 + 22 = 25\n//\u2502 > 2 + 25 = 27\n//\u2502 > 1 + 27 = 28\n//\u2502 = Some(28)\n\nsum of Nil\n//\u2502 = Some(0)\n\n// Try to make a disjunction of two patterns.\n\npattern SumOrDouble = SumList | DoubleList\n\nfun isSumOrDouble__translated(xs) = if xs is SumOrDouble as output then output else \"noop\"\n\nisSumOrDouble__translated of _1234\n//\u2502 > 4 + 0 = 4\n//\u2502 > 3 + 4 = 7\n//\u2502 > 2 + 7 = 9\n//\u2502 > 1 + 9 = 10\n//\u2502 = 10\n\nisSumOrDouble__translated of _1234567\n//\u2502 > 7 + 0 = 7\n//\u2502 > 6 + 7 = 13\n//\u2502 > 5 + 13 = 18\n//\u2502 > 4 + 18 = 22\n//\u2502 > 3 + 22 = 25\n//\u2502 > 2 + 25 = 27\n//\u2502 > 1 + 27 = 28\n//\u2502 = 28\n\nisSumOrDouble__translated of Nil\n//\u2502 = 0\n\nfun isSumOrDouble__compiled(xs) = if xs is (@compile SumOrDouble) as output then output else \"noop\"\n\nisSumOrDouble__compiled of _1234\n//\u2502 > 4 + 0 = 4\n//\u2502 > 3 + 4 = 7\n//\u2502 > 2 + 7 = 9\n//\u2502 > 1 + 9 = 10\n//\u2502 = 10\n\nisSumOrDouble__compiled of _1234567\n//\u2502 > 7 + 0 = 7\n//\u2502 > 6 + 7 = 13\n//\u2502 > 5 + 13 = 18\n//\u2502 > 4 + 18 = 22\n//\u2502 > 3 + 22 = 25\n//\u2502 > 2 + 25 = 27\n//\u2502 > 1 + 27 = 28\n//\u2502 = 28\n\nisSumOrDouble__compiled of Nil\n//\u2502 = 0\n\n// Swap the order of two patterns.\n\npattern DoubleOrSum = DoubleList | SumList\n\nfun isDoubleOrSum__translated(xs) = if xs is DoubleOrSum as output then output else \"noop\"\n\n:todo // Fix the return value of the translation.\nisDoubleOrSum__translated of _1234\n//\u2502 = Nil\n\nisDoubleOrSum__translated of list(1, 2, 3)\n//\u2502 > 3 + 0 = 3\n//\u2502 > 2 + 3 = 5\n//\u2502 > 1 + 5 = 6\n//\u2502 = 6\n\nfun isDoubleOrSum__compiled(xs) = if xs is (@compile DoubleOrSum) as output then output else \"noop\"\n\nisDoubleOrSum__compiled of _1234\n//\u2502 > 4 + 0 = 4\n//\u2502 > 3 + 4 = 7\n//\u2502 > 2 + 7 = 9\n//\u2502 = {head: 1, tail: {head: 2, tail: {head: 3, tail: {head: 4, tail: Nil}}}}\n\nisDoubleOrSum__compiled of _1234567\n//\u2502 > 7 + 0 = 7\n//\u2502 > 6 + 7 = 13\n//\u2502 > 5 + 13 = 18\n//\u2502 > 4 + 18 = 22\n//\u2502 > 3 + 22 = 25\n//\u2502 > 2 + 25 = 27\n//\u2502 > 1 + 27 = 28\n//\u2502 = 28\n");
    tmp6 = MutMap.insert("DoubleOrSum.mls", {
    "name": "Double or Sum", "group": "Nondeterministic", "source": tmp5
    });
    tmp7 = Predef.pipeInto(Examples.examples, tmp6);
    tmp8 = Examples.removeDiffTests(":js\n\nopen annotations\n\nimport \"../../../mlscript-compile/Stack.mls\"\nimport \"../../../mlscript-compile/Iter.mls\"\n\nopen Stack\n\nfun list(...elements) = elements Iter.toStack()\n\n// This pattern can flatten nested lists. It tries to flatten the head and\n// concatenate the output with the tail. If the head cannot be flattened, it\n// would just append the head to the flattened tail.\npattern Flatten =\n  (Nil => Nil) |\n  (((Flatten as hd) :: (Flatten as tl)) => hd ::: tl) |\n  ((hd :: (Flatten as tl)) => hd :: tl)\n\nfun flatten__translated(xs) =\n  if xs is Flatten as ys then\n    print of \"Flattened: [\" + (ys Iter.fromStack() Iter.joined(\", \")) + \"]\"\n  else \"Cannot flatten: \" + xs\n\nflatten__translated of Nil\n//\u2502 > Flattened: []\n\nflatten__translated of list(1)\n//\u2502 > Flattened: [1]\n\nflatten__translated of list(1, 2, 3, 4)\n//\u2502 > Flattened: [1, 2, 3, 4]\n\nflatten__translated of list(list(1, 2), list(3, 4))\n//\u2502 > Flattened: [1, 2, 3, 4]\n\nflatten__translated of list(list(list(list(1, 2, 3, 4))))\n//\u2502 > Flattened: [1, 2, 3, 4]\n\nflatten__translated of list(list(1, 2), list(list(3, 4), list(list(5, 6))))\n//\u2502 > Flattened: [1, 2, 3, 4, 5, 6]\n\nfun flatten__compiled(xs) =\n  if xs is (@compile Flatten) as ys then\n    print of \"Flattened: [\" + (ys Iter.fromStack() Iter.joined(\", \")) + \"]\"\n  else \"Cannot flatten: \" + xs\n\nflatten__compiled of Nil\n//\u2502 > Flattened: []\n\nflatten__compiled of list(1)\n//\u2502 > Flattened: [1]\n\nflatten__compiled of list(1, 2, 3, 4)\n//\u2502 > Flattened: [1, 2, 3, 4]\n\nflatten__compiled of list(list(1, 2), list(3, 4))\n//\u2502 > Flattened: [1, 2, 3, 4]\n\nflatten__compiled of list(list(list(list(1, 2, 3, 4))))\n//\u2502 > Flattened: [1, 2, 3, 4]\n\nflatten__compiled of list(list(1, 2), list(list(3, 4), list(list(5, 6))))\n//\u2502 > Flattened: [1, 2, 3, 4, 5, 6]\n");
    tmp9 = MutMap.insert("Flatten.mls", {
    "name": "List Flattening", "group": "Practical Examples", "source": tmp8
    });
    tmp10 = Predef.pipeInto(Examples.examples, tmp9);
    tmp11 = Examples.removeDiffTests(":js\n\nopen annotations\n\ndata class Celsius(value: Num)\n\ndata class Fahrenheit(value: Num)\n\npattern ToFahrenheit =\n  ((Celsius(c)) => Fahrenheit((c * 9 / 5) + 32)) |\n  ((Fahrenheit as f) => f)\n\npattern ToCelsius =\n  ((Fahrenheit(f)) => Celsius((f - 32) * 5 / 9)) |\n  ((Celsius as c) => c)\n\nCelsius(0) is ToFahrenheit(Fahrenheit(32))\n//\u2502 = true\n\nFahrenheit(212) is ToCelsius(Celsius(100))\n//\u2502 = true\n\nCelsius(100) is ToFahrenheit(Fahrenheit(212))\n//\u2502 = true\n\nFahrenheit(32) is ToCelsius(Celsius(0))\n//\u2502 = true\n\nCelsius(-40) is ToFahrenheit(Fahrenheit(-40))\n//\u2502 = true\n\nFahrenheit(-40) is ToCelsius(Celsius(-40))\n//\u2502 = true\n\nfun toFahrenheit(c) =\n  if c is (@compile ToFahrenheit) as output then output else \"What's this?\"\n\ntoFahrenheit of Celsius(100)\n//\u2502 = Fahrenheit(212)\n\ntoFahrenheit of Fahrenheit(100)\n//\u2502 = Fahrenheit(100)\n\ntoFahrenheit of Celsius(-40)\n//\u2502 = Fahrenheit(-40)\n\ntoFahrenheit of \"Cheers!\"\n//\u2502 = \"What's this?\"\n\nfun toCelsius(f) =\n  if f is (@compile ToCelsius) as output then output else \"What's this?\"\n\ntoCelsius of Fahrenheit(100)\n//\u2502 = Celsius(37.77777777777778)\n\ntoCelsius of Celsius(100)\n//\u2502 = Celsius(100)\n\ntoCelsius of \"Cheers!\"\n//\u2502 = \"What's this?\"\n\npattern HourAM = (0 => 12) | (1 ..= 11)\npattern HourPM = 12 | (((13 ..= 23) as hour) => hour - 12)\npattern Minute = ((0 ..= 59) as minute) => minute.toString().padStart(2, \"0\")\n\n// Convert 24-hour time format to 12-hour format with AM/PM\npattern Time12Hour = ((\n  hour: ((HourAM | HourPM) as hour) & (((HourAM => \"AM\") | (HourPM => \"PM\")) as flag),\n  minute: Minute as minute\n)) => hour + \":\" + minute + \" \" + flag\n\nfun formatTime(ps) = if ps is Time12Hour as time then time\n\nprint of \"I had my breakfast at\", formatTime of hour: 7, minute: 45\nprint of \"Let's have lunch at\", formatTime of hour: 12, minute: 30\nprint of \"I plan to have dinner at\", formatTime of hour: 18, minute: 45\nprint of \"I should go to bed before\", formatTime of hour: 23, minute: 0\n//\u2502 > I had my breakfast at 7:45 AM\n//\u2502 > Let's have lunch at 12:30 PM\n//\u2502 > I plan to have dinner at 6:45 PM\n//\u2502 > I should go to bed before 11:00 PM\n\n// This makes use of the chain pattern. It generates 29,232 lines of code!\npattern Time12Hour' = ((\n  hour: ((\n    ((0 ..= 11) => \"AM\") |\n    ((12 ..= 23) => \"PM\")\n  ) & (\n    (0 => 12) |\n    (1 ..= 11) |\n    12 |\n    ((13 ..= 23) as h => h - 12)\n  )) as [hour, flag],\n  minute: Minute as minute\n)) => hour + \":\" + minute + \" \" + flag\n\nfun formatTime'(ps) = if ps is Time12Hour' as time then time\n\nprint of \"I had my breakfast at\", formatTime' of hour: 7, minute: 45\nprint of \"Let's have lunch at\", formatTime' of hour: 12, minute: 30\nprint of \"I plan to have dinner at\", formatTime' of hour: 18, minute: 45\nprint of \"I should go to bed before\", formatTime' of hour: 23, minute: 0\n//\u2502 > I had my breakfast at AM:45 7\n//\u2502 > Let's have lunch at PM:30 12\n//\u2502 > I plan to have dinner at PM:45 6\n//\u2502 > I should go to bed before PM:00 11\n\npattern Channel = 0 ..= 255\n\n// Convert a color in RGB format to grayscale\npattern Grayscale =\n  ((r: Channel as r, g: Channel as g, b: Channel as b)) =>\n    Math.round(r * 0.299 + g * 0.587 + b * 0.114)\n\nfun grayscale(rgb) = if rgb is Grayscale as g then g else -1\n\ngrayscale of r: 0, g: 0, b: 0\n//\u2502 = 0\n\ngrayscale of r: 1, g: 1, b: 1\n//\u2502 = 1\n\ngrayscale of r: 255, g: 255, b: 255\n//\u2502 = 255\n\ngrayscale of r: 256, g: 255, b: 255\n//\u2502 = -1\n");
    tmp12 = MutMap.insert("Transformation.mls", {
    "name": "Pattern Transformation", "group": "Practical Examples", "source": tmp11
    });
    tmp13 = Predef.pipeInto(Examples.examples, tmp12);
    tmp14 = Examples.removeDiffTests(":js\n\nopen annotations\n\nfun check(pred, what) = Array.from(length: 10).forEach of (_, i, _) =>\n  let n = i.toString()\n  print of n, (if pred(n) then \"is\" else \"is not\"), what\n\npattern Zero = \"0\"\n\n:expect true\n\"0\" is Zero\n//\u2502 = true\n\npattern Binary = \"0\" | \"1\"\n\n// Currently, we expand range patterns into disjunction.\nfun isBinary(x) = x is @compile Binary\n\ncheck of isBinary, \"binary\"\n//\u2502 > 0 is binary\n//\u2502 > 1 is binary\n//\u2502 > 2 is not binary\n//\u2502 > 3 is not binary\n//\u2502 > 4 is not binary\n//\u2502 > 5 is not binary\n//\u2502 > 6 is not binary\n//\u2502 > 7 is not binary\n//\u2502 > 8 is not binary\n//\u2502 > 9 is not binary\n\n:expect false\n\"2\" is Binary\n//\u2502 = false\n\npattern Digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n\n:expect true\n\"0\" is Digit\n//\u2502 = true\n\n:expect true\n\"9\" is Digit\n//\u2502 = true\n\n:expect false\n\"a\" is Digit\n//\u2502 = false\n\nfun isDigit(x) = x is @compile Digit\n\ncheck of isDigit, \"digit\"\n//\u2502 > 0 is digit\n//\u2502 > 1 is digit\n//\u2502 > 2 is digit\n//\u2502 > 3 is digit\n//\u2502 > 4 is digit\n//\u2502 > 5 is digit\n//\u2502 > 6 is digit\n//\u2502 > 7 is digit\n//\u2502 > 8 is digit\n//\u2502 > 9 is digit\n\npattern Lower = \"a\"..=\"z\"\n\n:expect true\n\"a\" is Lower\n//\u2502 = true\n\n:expect true\n\"z\" is Lower\n//\u2502 = true\n\n:expect false\n\"0\" is Lower\n//\u2502 = false\n\npattern Upper = \"A\"..=\"Z\"\n\n:expect true\n\"A\" is Upper\n//\u2502 = true\n\n:expect true\n\"Q\" is Upper\n//\u2502 = true\n\n:expect false\n\"b\" is Upper\n//\u2502 = false\n\npattern Letter = Lower | Upper\n\n:expect true\n\"b\" is Letter\n//\u2502 = true\n\n:expect true\n\"V\" is Letter\n//\u2502 = true\n\n:expect false\n\"0\" is Letter\n//\u2502 = false\n\n:expect false\n\"9\" is Letter\n//\u2502 = false\n\n// Inspect the generated code. The use of `Map` makes the expanded disjunction\n// out of order. I wonder if we should use a `SeqMap` for literals.\nfun isLetter(x) = x is @compile Letter\n\nisLetter of \"a\"\n//\u2502 = true\n\nisLetter of \"0\"\n//\u2502 = false\n\npattern Word = Letter ~ (Word | \"\")\n\n:expect false\n\"\" is Word\n//\u2502 = false\n\n:expect true\n\"b\" is Word\n//\u2502 = true\n\n:expect true\n\"pattern\" is Word\n//\u2502 = true\n\n:expect false\n\"b0rked\" is Word\n//\u2502 = false\n\n:e\nfun isWord(x) = x is @compile Word\n//\u2502 \u2554\u2550\u2550[ERROR] String concatenation is not supported in pattern compilation.\n//\u2502 \u2551  l.120: \tpattern Word = Letter ~ (Word | \"\")\n//\u2502 \u2559\u2500\u2500       \t               ^^^^^^^^^^^^^^^^^^^\n\n// Unsupported patterns are equivalent to `Never`.\nisWord of \"pattern\"\n//\u2502 = false\n\npattern ManyDigits = (\"0\" ..= \"9\") ~ (ManyDigits | \"\")\n\n:expect true\n\"0\" is ManyDigits\n//\u2502 = true\n\n:expect true\n\"42\" is ManyDigits\n//\u2502 = true\n\n:expect true\n\"1234\" is ManyDigits\n//\u2502 = true\n\npattern Integer = \"0\" | (\"1\" ..= \"9\") ~ (ManyDigits | \"\")\n\n:expect true\n\"0\" is Integer\n//\u2502 = true\n\n:expect false\n\"012\" is Integer\n//\u2502 = false\n\n:expect true\n\"42\" is Integer\n//\u2502 = true\n\npattern IdentifierStart = Letter | \"_\"\n\npattern IdentifierBody = (Letter | Digit | \"_\") ~ (IdentifierBody | \"\")\n\npattern Identifier = IdentifierStart ~ (IdentifierBody | \"\")\n\n:expect true\n\"abc\" is Identifier\n//\u2502 = true\n\n:expect true\n\"abc123\" is Identifier\n//\u2502 = true\n\n:expect true\n\"abc_123\" is Identifier\n//\u2502 = true\n\n:expect true\n\"_abc_123\" is Identifier\n//\u2502 = true\n\n:expect false\n\"123abc\" is Identifier\n//\u2502 = false\n");
    tmp15 = MutMap.insert("Identifier.mls", {
    "name": "Identifiers", "group": "String Patterns", "source": tmp14
    });
    tmp16 = Predef.pipeInto(Examples.examples, tmp15);
    tmp17 = Examples.removeDiffTests(":js\n\npattern Digits = (\"0\"..=\"9\") ~ (Digits | \"\")\n\npattern Integer = \"0\" | (\"1\"..=\"9\") ~ (Digits | \"\")\n\npattern FractionalPart = \".\" ~ Digits\n\n\".1\" is FractionalPart\n//\u2502 = true\n\npattern ExponentPart = (\"e\" | \"E\") ~ (\"+\" | \"-\" | \"\") ~ Integer\n\n\"e10\" is ExponentPart\n//\u2502 = true\n\n\"e100\" is ExponentPart\n//\u2502 = true\n\npattern Number = Integer ~ (FractionalPart | \"\") ~ (ExponentPart | \"\")\n\n// Test cases for Digits pattern\n// =============================\n:expect true\n\"123\" is Digits\n//\u2502 = true\n\n:expect true\n\"0\" is Digits\n//\u2502 = true\n\n:expect true\n\"9\" is Digits\n//\u2502 = true\n\n:expect false\n\"a\" is Digits\n//\u2502 = false\n\n\n// Test cases for Integer pattern\n// ==============================\n:expect true\n\"0\" is Integer\n//\u2502 = true\n\n:expect true\n\"123\" is Integer\n//\u2502 = true\n\n:expect false\n\"001\" is Integer\n//\u2502 = false\n\n:expect false\n\"a\" is Integer\n//\u2502 = false\n\n\n// Test cases for FractionalPart pattern\n// =====================================\n:expect true\n\".123\" is FractionalPart\n//\u2502 = true\n\n:expect true\n\".0\" is FractionalPart\n//\u2502 = true\n\n:expect false\n\".\" is FractionalPart\n//\u2502 = false\n\n:expect false\n\"0.1\" is FractionalPart\n//\u2502 = false\n\n\n// Test cases for ExponentPart pattern\n// ===================================\n:expect true\n\"e10\" is ExponentPart\n//\u2502 = true\n\n:expect true\n\"E-10\" is ExponentPart\n//\u2502 = true\n\n:expect true\n\"e+10\" is ExponentPart\n//\u2502 = true\n\n:expect false\n\"e\" is ExponentPart\n//\u2502 = false\n\n:expect false\n\"e1a\" is ExponentPart\n//\u2502 = false\n\n\n// Test cases for Number pattern\n// =============================\n:expect true\n\"3.14\" is Number\n//\u2502 = true\n\n:expect true\n\"42\" is Number\n//\u2502 = true\n\n:expect true\n\"3.14e10\" is Number\n//\u2502 = true\n\n:expect true\n\"1e100\" is Number\n//\u2502 = true\n\n:expect true\n\"1234e-789\" is Number\n//\u2502 = true\n\n:expect true\n\"0.0314E+2\" is Number\n//\u2502 = true\n\n:expect true\n\"0.0314E-2\" is Number\n//\u2502 = true\n\n:expect false\n\".\" is Number\n//\u2502 = false\n\n:expect false\n\"e10\" is Number\n//\u2502 = false\n\n:expect false\n\"3.14e\" is Number\n//\u2502 = false\n\n:expect true\n\"3.14\" is Number\n//\u2502 = true\n\n:expect true\n\"42\" is Number\n//\u2502 = true\n\n:expect true\n\"3.14e10\" is Number\n//\u2502 = true\n\n:expect true\n\"1e100\" is Number\n//\u2502 = true\n\n:expect true\n\"1234e-789\" is Number\n//\u2502 = true\n\n:expect true\n\"0.0314E+2\" is Number\n//\u2502 = true\n\n:expect true\n\"0.0314E-2\" is Number\n//\u2502 = true\n\n:expect true\n\"1.7976931348623158e+308\" is Number\n//\u2502 = true\n");
    tmp18 = MutMap.insert("Number.mls", {
    "name": "Numbers", "group": "String Patterns", "source": tmp17
    });
    tmp19 = Predef.pipeInto(Examples.examples, tmp18);
    tmp20 = Examples.removeDiffTests(":js\n\nopen annotations { compile }\n\nobject A\nobject B\n\ndata class Node[T](left: Node[T], value: T, right: Node[T])\n\n// The patterns generate trees that have odd or even numbers of node `A`.\n\npattern OddTree =\n  A |\n  Node(EvenTree, A, EvenTree) | Node(OddTree, A, OddTree) |\n  Node(EvenTree, B, OddTree) | Node(OddTree, B, EvenTree)\npattern EvenTree =\n  B |\n  Node(EvenTree, A, OddTree) | Node(OddTree, A, EvenTree) |\n  Node(EvenTree, B, EvenTree) | Node(OddTree, B, OddTree)\n\nfun a(lc, rc) = Node(lc, A, rc)\n\nfun b(lc, rc) = Node(lc, B, rc)\n\nfun isEvenTree__compiled(tree) =\n  if tree is @compile EvenTree then true else false\n\nfun isEvenTree__naivelyTranslated(tree) =\n  if tree is EvenTree then true else false\n\nfun isOddTree__compiled(tree) =\n  if tree is @compile OddTree then true else false\n\nfun isOddTree__naivelyTranslated(tree) =\n  if tree is OddTree then true else false\n\n:global\n:expect true\n\n// Test each case of `EvenTree`.\n// =============================\n\nnot of isEvenTree__compiled of a(B, B)\n//\u2502 = true\n\nnot of isEvenTree__naivelyTranslated of a(B, B)\n//\u2502 = true\n\nisEvenTree__compiled of B\n//\u2502 = true\n\nisEvenTree__naivelyTranslated of B\n//\u2502 = true\n\nnot of isEvenTree__compiled of A\n//\u2502 = true\n\nnot of isEvenTree__naivelyTranslated of A\n//\u2502 = true\n\nnot of isEvenTree__compiled of a(B, B)\n//\u2502 = true\n\nnot of isEvenTree__naivelyTranslated of a(B, B)\n//\u2502 = true\n\nisEvenTree__compiled of a(B, A)\n//\u2502 = true\n\nisEvenTree__naivelyTranslated of a(B, A)\n//\u2502 = true\n\nisEvenTree__compiled of a(A, B)\n//\u2502 = true\n\nisEvenTree__naivelyTranslated of a(A, B)\n//\u2502 = true\n\nisEvenTree__compiled of b(A, A)\n//\u2502 = true\n\nisEvenTree__naivelyTranslated of b(A, A)\n//\u2502 = true\n\nisEvenTree__compiled of b(B, B)\n//\u2502 = true\n\nisEvenTree__naivelyTranslated of b(B, B)\n//\u2502 = true\n\n// Test each case of `OddTree`.\n// ============================\n\nisOddTree__compiled of A\n//\u2502 = true\n\nisOddTree__naivelyTranslated of A\n//\u2502 = true\n\nisOddTree__compiled of a(B, B)\n//\u2502 = true\n\nisOddTree__naivelyTranslated of a(B, B)\n//\u2502 = true\n\nisOddTree__compiled of a(A, A)\n//\u2502 = true\n\nisOddTree__naivelyTranslated of a(A, A)\n//\u2502 = true\n\nisOddTree__compiled of b(B, A)\n//\u2502 = true\n\nisOddTree__naivelyTranslated of b(B, A)\n//\u2502 = true\n\nisOddTree__compiled of b(A, B)\n//\u2502 = true\n\nisOddTree__naivelyTranslated of b(A, B)\n//\u2502 = true\n");
    tmp21 = MutMap.insert("EvenOddTree.mls", {
    "name": "Even and Odd Trees", "group": "Nondeterministic", "source": tmp20
    });
    tmp22 = Predef.pipeInto(Examples.examples, tmp21);
    tmp23 = Examples.removeDiffTests(":js\n\nopen annotations { compile }\n\ndata\n  class\n    (&&) And(lhs: Bool, rhs: Bool)\n    (||) Or(lhs: Bool, rhs: Bool)\n    Not(arg: Bool)\n\npattern Truthy =\n  true | And(Truthy, Truthy) | Or(Truthy, Truthy) |\n  Or(Truthy, Falsy) | Or(Falsy, Truthy) | Not(Falsy)\npattern Falsy =\n  false | And(Falsy, Falsy) | And(Falsy, Truthy) |\n  And(Truthy, Falsy) | Or(Falsy, Falsy) | Not(Truthy)\n\n:expect [true, false, false, true]\n[\n  true is @compile Truthy,\n  false is @compile Truthy,\n  true is @compile Falsy,\n  false is @compile Falsy\n]\n//\u2502 = [true, false, false, true]\n\nfun isTruthy(value) = value is @compile Truthy\n\nfun isFalsy(value) = value is @compile Falsy\n\nfun isTruthy'(value) = value is Truthy\n\nfun isFalsy'(value) = value is Falsy\n\n:global\n:expect true\n\n// Test each case of `Truthy`.\n// ===========================\n\nisTruthy of true\n//\u2502 = true\n\nisTruthy' of true\n//\u2502 = true\n\nisTruthy of true && true\n//\u2502 = true\n\nisTruthy' of true && true\n//\u2502 = true\n\nisTruthy of true || true\n//\u2502 = true\n\nisTruthy' of true || true\n//\u2502 = true\n\nisTruthy of true || false\n//\u2502 = true\n\nisTruthy' of true || false\n//\u2502 = true\n\nisTruthy of false || true\n//\u2502 = true\n\nisTruthy' of false || true\n//\u2502 = true\n\nisTruthy of Not of false\n//\u2502 = true\n\nisTruthy' of Not of false\n//\u2502 = true\n\n// Test each case of `Falsy`.\n// ==========================\n\nisFalsy of false\n//\u2502 = true\n\nisFalsy of false && false\n//\u2502 = true\n\n// This example requires the ability to handle non-determinism.\nisFalsy of false && true\n//\u2502 = true\n\nisFalsy' of false && true\n//\u2502 = true\n\nisFalsy of true && false\n//\u2502 = true\n\nisFalsy' of true && false\n//\u2502 = true\n\nisFalsy of false || false\n//\u2502 = true\n\nisFalsy' of false || false\n//\u2502 = true\n\nisFalsy of Not of true\n//\u2502 = true\n\nisFalsy' of Not of true\n//\u2502 = true\n");
    tmp24 = MutMap.insert("TruthyFalsy.mls", {
    "name": "Truthy and Falsy", "group": "Nondeterministic", "source": tmp23
    });
    Predef.pipeInto(Examples.examples, tmp24)
  }
  static removeDiffTests(source) {
    let tmp, tmp1;
    tmp = source.replaceAll(Examples.diffTestPattern, "");
    tmp1 = tmp.replaceAll(Examples.compileImports, "std/$1");
    return runtime.safeCall(tmp1.trim())
  } 
  static get grouped() {
    let groups, tmp, tmp1, lambda;
    groups = MutMap.empty;
    lambda = (undefined, function (caseScrut) {
      let first1, first0, key, example, tmp2, tmp3, tmp4, lambda1;
      if (globalThis.Array.isArray(caseScrut) && caseScrut.length === 2) {
        first0 = caseScrut[0];
        first1 = caseScrut[1];
        key = first0;
        example = first1;
        tmp2 = MutMap.updateWith(example.group);
        lambda1 = (undefined, function (caseScrut1) {
          let param0, group, tmp5;
          if (caseScrut1 instanceof Option.Some.class) {
            param0 = caseScrut1.value;
            group = param0;
            tmp5 = runtime.safeCall(group.push([
              key,
              example
            ]));
            return runtime.safeCall(Option.Some(group))
          } else if (caseScrut1 instanceof Option.None.class) {
            return runtime.safeCall(Option.Some([
              [
                key,
                example
              ]
            ]))
          } else {
            throw new globalThis.Error("match error");
          }
        });
        tmp3 = lambda1;
        tmp4 = runtime.safeCall(tmp2(tmp3));
        return Predef.pipeInto(groups, tmp4)
      } else {
        throw new globalThis.Error("match error");
      }
    });
    tmp = lambda;
    tmp1 = Iter.each(Examples.examples, tmp);
    return groups;
  }
  static toString() { return "Examples"; }
});
let Examples = Examples1; export default Examples;
